{% extends 'layout.html' %}
{% block content %}

<div class="container py-5">
    <h1 class="mb-4">Edit Image</h1>
    
    <div class="row">
        <div class="col-md-6">
            <img src="{{ url_for('static', filename='images/' + image.filename) }}" 
                    class="img-fluid mb-3">
        </div>
        <div class="col-md-6">
            <form method="POST" action="{{ url_for('update_image', image_id=image.id) }}">
                <div class="mb-3">
                    <label class="form-label">Description</label>
                    <textarea name="description" class="form-control" rows="3">{{ image.description or '' }}</textarea>
                </div>
                
                <button type="submit" class="btn btn-primary">Save Changes</button>
                <a href="{{ url_for('gallery') }}" class="btn btn-outline-secondary">Cancel</a>
            </form>
        </div>
    </div>
</div>

<div class="card mb-4">
    <div class="card-header d-flex justify-content-between align-items-center">
        <h5>Tags</h5>
        <small class="text-muted tag-counter">
            <span id="currentTagCount">{{ image.tags|length }}</span>/8 tags
        </small>
    </div>
    <div class="card-body">
        <!-- Current Tags -->
        <div class="mb-3" id="currentTags">
            {% for tag in image.tags %}
            <span class="badge bg-primary me-2 mb-2">
                {{ tag.name }}
                <button type="button" class="btn-close btn-close-white ms-1" 
                        onclick="removeTag({{ image.id }}, '{{ tag.name }}')"></button>
            </span>
            {% endfor %}
        </div>

        <!-- Tag Input -->
        <div class="input-group mb-3">
            <input type="text" id="newTagInput" class="form-control" 
                   placeholder="New tag (max 20 chars)" maxlength="20">
            <button class="btn btn-primary" type="button" id="addTagBtn">Add</button>
        </div>

        <!-- Suggestions -->
        {% if all_tags %}
        <div class="mt-3">
            <h6>Existing Tags</h6>
            <div class="d-flex flex-wrap gap-2" id="suggestedTags">
                {% for tag in all_tags %}
                {% if tag not in image.tags|map(attribute='name') %}
                <button type="button" class="btn btn-sm btn-outline-secondary tag-suggestion"
                        onclick="addTag('{{ image.id }}', '{{ tag }}')">
                    {{ tag }}
                </button>
                {% endif %}
                {% endfor %}
            </div>
        </div>
        {% endif %}
    </div>
</div>

{% endblock %}

{% block extra_js %}
<script>
async function addTag(imageId, tagName) {
    const currentTags = document.getElementById('currentTags');
    if (currentTags.querySelectorAll('.badge').length >= 8) {
        alert("Maximum 8 tags per image");
        return;
    }

    try {
        const response = await fetch(`/add_tag/${imageId}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ tag: tagName })
        });
        
        const result = await response.json();
        
        if (response.ok) {
            // Add new tag badge
            const badge = document.createElement('span');
            badge.className = 'badge bg-primary me-2 mb-2';
            badge.innerHTML = `${result.tag} <button type="button" 
                            class="btn-close btn-close-white ms-1" 
                            onclick="removeTag(${imageId}, ${result.tag_id})"></button>`;
            currentTags.appendChild(badge);
            updateTagCount();
        } else {
            alert(result.error);
        }
    } catch (error) {
        console.error("Error:", error);
    }
}

// Tag Management
function updateTagCount(imageId) {
    const count = document.querySelectorAll(`#currentTags .badge`).length;
    document.getElementById('currentTagCount').textContent = count;
    
    // Disable input if limit reached
    if (count >= 8) {
        document.getElementById('newTagInput').disabled = true;
        document.getElementById('addTagBtn').disabled = true;
        document.getElementById('newTagInput').placeholder = "Maximum tags reached";
    }
}

// Add new tag
document.getElementById('addTagBtn').addEventListener('click', async function() {
    const tag = document.getElementById('newTagInput').value.trim();
    const imageId = {{ image.id|tojson }};
    
    if (!tag) return;
    if (tag.length > 20) {
        alert("Tag must be 20 characters or less");
        return;
    }
    
    await addTag(imageId, tag);
    document.getElementById('newTagInput').value = '';
});

// Typeahead suggestions
document.getElementById('newTagInput').addEventListener('input', function() {
    const search = this.value.toLowerCase();
    const buttons = document.querySelectorAll('#suggestedTags button');
    
    buttons.forEach(btn => {
        const match = btn.textContent.toLowerCase().includes(search);
        btn.style.display = match ? 'inline-block' : 'none';
    });
});

// Helper functions
async function addTag(imageId, tagName) {
    const currentTags = document.getElementById('currentTags');
    const tagCount = currentTags.querySelectorAll('.badge').length;
    
    if (tagCount >= 8) {
        alert("Maximum 8 tags per image");
        return;
    }
    
    try {
        const response = await fetch(`/add_tag/${imageId}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ tag: tagName })
        });
        
        if (response.ok) {
            const badge = document.createElement('span');
            badge.className = 'badge bg-primary me-2 mb-2';
            badge.innerHTML = `${tagName} <button type="button" class="btn-close btn-close-white ms-1" 
                             onclick="removeTag(${imageId}, '${tagName.replace("'", "\\'")}')"></button>`;
            currentTags.appendChild(badge);
            updateTagCount(imageId);
        } else {
            alert(await response.text());
        }
    } catch (error) {
        console.error("Error adding tag:", error);
    }
}

// Fuzzy matching for suggestions
function findSimilarTags(input) {
    const existingTags = [...document.querySelectorAll('#existingTags button')]
        .map(btn => btn.dataset.tag.toLowerCase());
    
    return existingTags.filter(tag => 
        tag.includes(input.toLowerCase()) || 
        similarity(tag, input.toLowerCase()) > 0.7
    );
}

// Simple similarity algorithm (0-1 scale)
function similarity(s1, s2) {
    const longer = s1.length > s2.length ? s1 : s2;
    const shorter = s1 === longer ? s2 : s1;
    return longer.includes(shorter) ? 1 : 0;
}

// Auto-suggest while typing
document.getElementById('newTagInput').addEventListener('input', function(e) {
    const input = e.target.value.trim();
    if (input.length < 2) return;
    
    const matches = findSimilarTags(input);
    highlightSuggestions(matches);
});
</script>
{% endblock %}